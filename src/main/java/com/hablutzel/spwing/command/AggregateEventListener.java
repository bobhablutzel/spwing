/*
 * Copyright Â© 2023. Hablutzel Consulting, LLC. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.hablutzel.spwing.command;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.swing.event.UndoableEditListener;
import javax.swing.undo.UndoManager;
import javax.swing.undo.UndoableEdit;


/**
 * The AggregateEventListener is the base for listeners that collect
 * multiple undoable edits - particularly those generated by Swing UI
 * elements - and aggregate them into a single undoable edit. Subclasses
 * will listen for specific events, such as those generated by
 * the {@link javax.swing.text.JTextComponent} classes. This listener
 * uses a {@link AggregateEdit} to aggregate the edits into a single edit
 * for undo/redo.
 *
 * @param <T> The aggregated edit type
 * @author Bob Hablutzel
 */
@RequiredArgsConstructor
@Slf4j
public abstract class AggregateEventListener<T extends UndoableEdit> implements UndoableEditListener {

    /**
     * The active undo manager (so we can add new undoable edits).
     */
    @Getter
    private final UndoManager undoManager;

    /**
     * The current aggregate edit
     */
    protected AggregateEdit<T> current;


    /**
     * Create a new aggregate edit to start collecting atomic edits.
     * This will check to make sure the current aggregate edit is
     * named the same as the newly provided presentation name, is
     * non-empty and avoid creating a new one if the aggregate is empty
     * @param presentationName The new presentation name
     */
    public void createNewAggregateEdit(final String presentationName) {
        if (current == null || !presentationName.equals(current.getPresentationName()) || !current.isEmpty()) {
            current = new AggregateEdit<>(presentationName,this);
            undoManager.addEdit(current);
        }
    }


    /**
     * Alter the listener that the aggregate edit is no longer current.
     * This can happen when it is undone, so that it no longer can
     * aggregate new events. The aggregate edit being closed is passed in
     * and compared to the current aggregate edit (if any). Note that
     * closing an aggregate edit is different than having that edit die.
     *
     * @param aggregateEdit The closing edit
     */
    public void noLongerCurrent(AggregateEdit<T> aggregateEdit) {
        if (aggregateEdit == current) {
            current = null;
        }
    }

    /**
     * Force the current edit to close
     */
    public void closeCurrent() {
        this.current = null;
    }

}
